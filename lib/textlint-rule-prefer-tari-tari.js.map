{"version":3,"sources":["../src/textlint-rule-prefer-tari-tari.js"],"names":["japaneseParser","JapaneseParser","require","StringSource","nlcstToString","動詞","type","data","pos","pos_detail_1","たり","surface_form","する","basic_form","report","context","Syntax","RuleError","Paragraph","node","ready","then","matcher","PatternMatcher","parser","TARI_SURU","tag","TARI","VERB","source","text","toString","CST","parse","children","length","sentences","isSameNode","resultsA","resultsB","some","resultA","resultB","index","forEach","sentence","tariResults","matchCST","tariSuruResults","suru","afterSuru","find","firstToken","nodeList","suruFirstToken","prevSuruNode","indexOf","prevIsNotTari","position","start","offset","originalIndexFromIndex","module","exports","linter","fixer"],"mappings":"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","file":"textlint-rule-prefer-tari-tari.js","sourcesContent":["// MIT © 2017 azu\n\"use strict\";\nimport { JapaneseParser } from \"nlcst-parse-japanese\";\nimport { match, PatternMatcher } from \"nlcst-pattern-match\";\n\nconst japaneseParser = new JapaneseParser();\nconst { StringSource } = require(\"textlint-util-to-string\");\nconst nlcstToString = require(\"nlcst-to-string\");\n// definition\nconst 動詞 = {\n    type: \"WordNode\",\n    data: {\n        pos: \"動詞\",\n        pos_detail_1: [\"自立\", \"非自立\"]\n    }\n};\nconst たり = {\n    type: \"WordNode\",\n    data: {\n        pos: \"助詞\",\n        surface_form: [\"だり\", \"たり\"]\n    }\n};\nconst する = {\n    type: \"WordNode\",\n    data: {\n        basic_form: \"する\"\n    }\n};\nconst report = (context) => {\n    const { Syntax, RuleError, report } = context;\n    return {\n        [Syntax.Paragraph](node) {\n            return japaneseParser.ready().then(() => {\n                const matcher = new PatternMatcher({\n                    parser: japaneseParser\n                });\n                const TARI_SURU = matcher.tag`${動詞}${たり}${する}`;\n                const TARI = matcher.tag`${動詞}${たり}`;\n                const VERB = matcher.tag`${動詞}`;\n                const source = new StringSource(node);\n                const text = source.toString();\n                const CST = japaneseParser.parse(text);\n                // Ignore empty Paragraph. Ex) '<p></p>'\n                if (typeof CST.children === \"undefined\" || CST.children.length == 0) {\n                    return;\n                }\n                const sentences = CST.children[0].children;\n                const isSameNode = (resultsA, resultsB) => {\n                    return resultsA.some((resultA) => {\n                        return resultsB.some((resultB) => {\n                            return resultB.index === resultA.index;\n                        });\n                    });\n                };\n                sentences.forEach((sentence) => {\n                    const tariResults = matcher.matchCST(sentence, TARI);\n                    const tariSuruResults = matcher.matchCST(sentence, TARI_SURU);\n                    // `${動詞}${たり}` かつ `${動詞}${たり}${する}` の場合は除外\n                    if (isSameNode(tariResults, tariSuruResults)) {\n                        return;\n                    }\n                    if (tariResults.length === 1) {\n                        const suru = matcher.matchCST(sentence, VERB);\n                        const afterSuru = suru.find((suru) => {\n                            const firstToken = tariResults[0].nodeList[0];\n                            const suruFirstToken = suru.nodeList[0];\n                            const prevSuruNode = sentence.children[sentence.children.indexOf(suruFirstToken) - 1];\n                            // 逃げ\"たり\"しない のようなパターン\n                            const prevIsNotTari = prevSuruNode && nlcstToString(prevSuruNode) !== \"たり\";\n                            // 最初の\"たり\"より後ろ\n                            return (\n                                prevIsNotTari &&\n                                suruFirstToken.position.start.offset > firstToken.position.start.offset &&\n                                // not たり\n                                match(suru.nodeList, TARI)\n                            );\n                        });\n                        if (!afterSuru) {\n                            return;\n                        }\n                        // report\n                        // console.log(afterSuru.nodeList);\n                        report(\n                            node,\n                            new RuleError(\n                                `例示・並列・対表現において、片方の動詞が「〜たり」表現な場合は、もう片方の動詞も「〜たり」とします。`,\n                                {\n                                    index: source.originalIndexFromIndex(afterSuru.position.index)\n                                }\n                            )\n                        );\n                    }\n                });\n            });\n        }\n    };\n};\nmodule.exports = {\n    linter: report,\n    fixer: report\n};\n"]}